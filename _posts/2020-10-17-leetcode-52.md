---
layout:     post
title:      leetcode-52
subtitle:   leetcode
date:       2020-10-17
author:     scpi
header-img: img/leetcode_background.jpg
catalog:	true
tags:
    - leetcode
---



[52. N皇后 II](https://leetcode-cn.com/problems/n-queens-ii/)

## 每日一题

今天的每日一题，久违地看到了难度系数为困难的题，久违地很快就作了出来，但原因似乎是因为这是困难里最简单的那种题目。。

其实N皇后与8皇后并没有太大区别，都是使用递归就可以很简单地得出答案的题目。

但看官方题解，我的算法可以优化的地方其实还是很多的。

我使用了一个二维的整数数组来保存棋盘，有皇后的位置其值为1，否则为0，然后对每个遍历到的位置判断是否可以放置皇后，具体做法是维护两个指针来指向斜对角线上的位置，对当前行之上的每一行判断当前列，斜对角线上是否有皇后，这样做的的话，仅仅是判断是否可以放置皇后的时间复杂度都为O(n)，整个算法的时间复杂度估略能达到O(n! * n)，空间复杂度要O(n^2)，真的是非常的低效。

官方题解给出了两种方法作为优化方案

#### 基于集合的回溯

具体来讲，维护三个集合分别保存已经有皇后的**列，左斜对角线，右斜对角线**，维护一个集合来保存有皇后的列还很容易理解，那么保存对角线上的皇后的集合是什么意思呢。

请看下图(这是官方题解里的图。也不知道这样合适不合适)：

[![0XSLaF.png](https://s1.ax1x.com/2020/10/18/0XSLaF.png)](https://imgchr.com/i/0XSLaF)

观察之后很容易发现，对于这样子向右下方走的对角线，同一条对角线上他们的行下标减去列下标得到的值是固定的，所以我们就可以存储这个值来代表这条对角线，然后就可以判断当前遍历到的节点是否在这条对角线上。

对于另一种向斜上方走的对角线，观察后发现他们的规律是：同一条对角线上行下标与列下标之和固定。

使用这三个集合来保存有皇后存在的列、对角线，所需的空间复杂度为O(n)，判断当前节点是否可以放置皇后的时间复杂度则是常数级，总的时间复杂度是O(n!)，高效了很多。

#### 基于位运算的回溯

上一种优化是使用了集合保存不可以放置皇后的位置，官方在给出的第二种方案中使用了位运算来计算可以放置皇后的位置来递归得到结果。

其实这种方法的空间复杂度依旧是O(n)，时间复杂度也没有变化。而且因为是使用的位运算，其实并不怎么好理解。不想看的其实可以跳过。

粗略的讲一下，就是使用三个整数来保存每一行不能放置皇后的列，对角线一与对角线二，分别是向左下方走的对角线与向右下方走的对角线。

找到当前行可以放置皇后的节点之后，把这三个整数作一定变化后传给下一层进行递归，具体来讲，变化分别是，将当前位置添加到列所对应的整数中，使用**位与**运算很简单就可以做到，将当前位置添加到对角线一对应的整数中后，将对角线一对应的整数作向左位移一位(或者向右位移，如果你是使用整数低位对应棋盘低位)，使用**位与与位移**运算很简单就可以做到，对角线二的处理类似。

那么怎么通过这三个整数找到可以放置皇后的节点并遍历这些节点呢？

其实很简单，所有的这些节点可以通过接下来的算式得到：`(2^n^ - 1) & (~(columns | diagonals1 | diagonals2))`

> columns保存不能放置皇后的列，diagonals1保存不能放置皇后的左下对角线，diagonals2保存不能放置皇后的右下对角线。

这样得到的是所有可以放置皇后的位置，怎么遍历他们呢？

这就要利用到位运算的下列两个性质：

* x & (-x)可以得到x的二进制表示中最低位的1的位置
* x & (x - 1)可以将x的二进制表示中最地位的1设为0

> 为什么有这两个性质，因为计算机中数据都是以补码表示的。

也就是说，每次获取x中最地位的1所代表的数字，同时将代表可遍历位置数字的对应位设为0，直到可遍历数字为0，所有可遍历的位置就都遍历过了。

其实效率也没提升多少。但就当学习位运算了。知识总不会背叛自己。

最上面的链接里有代码，也有更具体(?)的解释，感兴趣的可以看看。

为了某些懒癌患者着想，贴一下代码。

```java
public int totalNQueens(int n) {
    return solve(n, 0, 0, 0, 0);
}

private int solve(int n, int row, int columns, int diagonals1, int diagonals2) {
    if (row == n)
        return 1;
    else {
        int count = 0;
        int availablePositions = ((1 << n) - 1) & (~(columns | diagonals1 | diagonals2));
        while (availablePositions != 0) {
            int position = availablePositions & (-availablePositions);
            availablePositions &= (availablePositions - 1);
            count += solve(n, row + 1, columns | position, (diagonals1 | position) >> 1, (diagonals2 | position) << 1);
        }
        return count;
    }
}
```

> 我的代码和官方题解有一点点不一样，数字高位对应的是棋盘低位。其实效果一样，只是我觉得这样比较舒服。

