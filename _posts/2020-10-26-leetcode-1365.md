---
layout:     post
title:      leetcode-1365
subtitle:   leetcode
date:       2020-10-26
author:     scpi
header-img: img/leetcode_background.jpg
catalog:	true
tags:
    - leetcode
---



[1365. 有多少小于当前数字的数字](https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number/)

今天的每日一题，难度系数为简单。

```
给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。
换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j != i 且 nums[j] < nums[i] 。
以数组形式返回答案。

示例 1：
输入：nums = [8,1,2,2,3]
输出：[4,0,1,1,3]
解释： 
对于 nums[0]=8 存在四个比它小的数字：（1，2，2 和 3）。 
对于 nums[1]=1 不存在比它小的数字。
对于 nums[2]=2 存在一个比它小的数字：（1）。 
对于 nums[3]=2 存在一个比它小的数字：（1）。 
对于 nums[4]=3 存在三个比它小的数字：（1，2 和 2）。

示例 2：
输入：nums = [6,5,4,8]
输出：[2,1,0,3]

示例 3：
输入：nums = [7,7,7,7]
输出：[0,0,0,0]

提示：
2 <= nums.length <= 500
0 <= nums[i] <= 100
```

难度系数为简单，确实是很简单，照理来说应该是没什么好写的，但因为这道题非常适合使用**计数排序**来做，所以其实还是可以有那么一点点可写的东西的。

#### 暴力算法

按照管理，我们先从最无脑的暴力算法开始说起。

就是在遍历元素的过程中，依次比较当前元素与其他元素的值并更新结果数组中的值呗。

> 其实有一点点可以进行优化的地方。
>
> 记当前元素为第`i`个元素，存在`j`满足`i < j < Array.length`。如果`Array[i] > Array[j]`则我们更新`ans[i]`的值，而如果`Array[i] < Array[j]`则我们更新`ans[j]`的值，这样的话我们每次都可以让内层循环的`j`初始化为`i + 1`，降低一点点时间复杂度。
>
> 但没什么用。效率还是太低了。

#### 计数排序

> 计数排序是桶排序的一种特殊情况，是为数不多的线性时间复杂度的排序算法。但应用场景限制很大。
>
> 讲计数排序和桶排序的文章其实挺多的。虽然我觉得没必要在这里赘述，但因为今天的题目实在太简单了没什么可写的，同时也是复习一下。我决定还是把他们介绍一下。

##### 筒排序

当我们需要排序的数据比较均匀地分布在某个区间中，我们就可以考虑使用筒排序。

筒排序的根本思想是将数据分隔到几个有序的筒之中，对每个筒内的元素进行快速排序，再将筒内的数据依次取出，全部的数据就排序完成。

举个栗子：

我们对某个电商平台的订单按照金额进行排序，这些订单的金额由几元到上万元不止。那么我们可以分出这样的几个筒，`0-30`元一个筒，`30-80`元一个筒，`80-200`一个筒，`200-500`一个筒...我们只需要遍历一次原始数据，就可以把不同金额的订单划分到他们对应的筒之中，划分完成之后，我们对每个筒分别进行快速排序，排序完成后依次将各个筒内的元素取出组成一个新的集合，这个集合就完成了排序。

那么这个排序算法的时间复杂度是多少呢？为什么不直接使用快排呢？有种多此一举的感觉？

其实不是的。在**特定的情况下**，筒排序可以达到O(n)时间复杂度，优于快排的O(n*logn)。

但仅限于特定的情况啦。想使用筒排序，原始数据必须可以很简单地就可以划分成为几个筒，并且筒与筒之间还需要具有天然的大小关系，保证我们在筒内排序完成后不需要再进行筒间排序，同时还需要保证筒内的数据分布相对均匀，极端情况下，只有一个筒内有数据，其他筒内都没有数据，筒排序就退化为快排啦。

##### 计数排序

那么说完了筒排序，计数排序又是什么东西呢？

就像我之前说的一样，技术排序是一种特殊的筒排序。

考虑这样一个栗子：

高考察分。每年高考的考生以数十万记，我们怎样对这些考生的成绩进行排序呢？最好的解决办法是什么呢？答案就是计数排序。

筒排序使用筒来保存处于同一区间内的数据。极端情况下，我们可以让筒的区间只包含一个值，这样的筒排序就被称为计数排序。

具体到这个栗子。

全国一卷的总分不过750分。也就是说，全部考生的成绩一定分布在0-750这个区间内。我们维护751数组，第一个数组保存成绩为0的考生，第二个保存成绩为1的......

遍历一次考生集合，再将751个筒内的数据整合起来，排序即完成。

很显然计数排序的时间复杂度为O(n)。同时，计数排序的使用条件**更为苛刻**。

##### 题解

那么回到本题目，我们需要的是得到每个元素在数组中小于他的值的元素的数目，这和排序有什么关系。

和排序当然没关系，但我们可以借鉴计数排序的思想。

注意题目描述中提到`0 <= nums[i] <= 100`，那么我们可以维护一个数组`cnt`，`cnt[i]`表示原始数据集合中值为`i`的元素的个数。那么结果集合`ans`中，`ans[i]`就等于`cnt[0],cnt[1]...cnt[i - 1]`的和。

贴一下代码：

```java
public int[] smallerNumbersThanCurrent(int[] nums) {
    int[] cnt = new int[101];
    int n = nums.length;
    for (int i = 0; i < n; i++) {
        cnt[nums[i]]++;
    }
    for (int i = 1; i <= 100; i++) {
        cnt[i] += cnt[i - 1];
    }
    int[] ret = new int[n];
    for (int i = 0; i < n; i++) {
        ret[i] = nums[i] == 0 ? 0 : cnt[nums[i] - 1];
    }
    return ret;
}
```

#### 快速排序

其实也没什么好说的，就是在快排的同时保存了数据在原始数据集合中的位置。

我在最后提了一下这个的原因只是我有些在意一开始居然没想到要这么做。

虽然我还是觉得计数排序是最优解。但居然完全没想到这种解法。

