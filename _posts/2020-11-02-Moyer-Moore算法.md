---
layout:     post
title:      字符串匹配算法-BM算法
subtitle:   算法学习笔记
date:       2020-11-03
author:     scpi
header-img: img/leetcode_background.jpg
catalog:	true
tags:
    - 算法学习笔记
	- 字符串匹配算法
---

### BM算法

之前不是被字符串给支配了一次么。我就想着要好好去复习一下字符串匹配相关的内容，**BM,KMP,Trie,AC自动机**之类的，花点时间全部再细细地过一遍。

当然每天的每日一题还是不能少了的。*但在每日一题很简单没什么好写的东西的日子里，就是复习这些算法的时机了*。比如今天。

BM算法的全称是Boyer-Moore，他是一种非常高效的字符串匹配算法，他的性能甚至可以高过著名的`KMP`算法。但是比较难。原理有一点点复杂。

在开始之前，先让我们定义两个概念：**主串、模式串**。举个栗子，我们在字符串A中寻找是否存在字符串B，则A就是主串，B则是模式串。

为了理解BM算法，我们可以先从最简单的BF算法，也就是暴力算法说起。

在暴力算法中，我们遍历主串的每一个字符，然后尝试以该字符为首的子字符串是否匹配模式串，若不匹配，则后移主串中的字符开始下一次尝试。写成代码就是这样：

```java
public int bf(char[] primary, char[] pattern) {
    for (int i = 0; i <= primary.length - pattern.length; ++i) {
        int j;
        for (j = 0; j < pattern.length; ++j) {
            if (primary[i + j] != pattern[j])
                break;
        }
        if (j == pattern.length)
            return i;
    }
    return -1;
}
```

是不是很好理解。

但同时简单的代价是低效。简单分析一下，BF算法的最坏时间复杂度可以达到$O(n * m)$，其中$n$是`primary`的长度，$m$是`pattern`的长度。

> 虽然看起来好像效率不高但实际上在实际应用中BF算法的出场率其实并不低，一方面m的大小一般并不大，另一方面最坏事件复杂度并不容易达到，我们总是在匹配到一般时就可以发现无法匹配从而退出循环。最重要的是，很简单。简单意味着容易维护。而且BF算法也可以做一些简单的优化来提高效率，比如RK算法，虽然效率不及BM或是KMP，但一般来讲够用。

那么我们怎样来提高效率呢？是指那种提升很大的提升。

观察发现我们每次都会在主串中后移一位，如果一次性可以后移很多位，那么效率自然而然就会提升很多。那么怎样判断后移的位数呢？

这就要提到BM算法的**坏字符**与**好后缀**规则了。他们两个规则都是拿来计算后移的位数的规则，既然有两个规则，那么我们应该选择哪个规则呢？不急，之后我们会提到的。

#### 坏字符

先来看看坏字符规则。

在BF算法中，我们是按模式串从前向后的方向遍历判断模式串与主串中某个子串是否匹配。但是在BM算法中，我们需要按模式串从后向前的方向遍历**模式串**(不是主串)与主串的子串判断他们是否匹配。

[![BrD0jU.md.jpg](https://s1.ax1x.com/2020/11/02/BrD0jU.md.jpg)](https://imgchr.com/i/BrD0jU)

看看我画的~~渣~~图。我们的模式串为`abc`，主串为`aba`，从前向后遍历主串，判断对应的子串是否与模式串匹配，判断的时候从后向前遍历模式串，找到的第一个不匹配的字符为`a`，其在**模式串**(注意是模式串)中对应的下标为2(`a`对应模式串中的`c`)，不提算法，我们凭直觉来看，将模式串往后移一位是否能成功匹配呢？不可能的。因为模式串中下标为`1`的字符为`b`，与`a`不匹配。我们可以直接向后滑动2位，这样至少`a`匹配了，**有可能匹配**。

再来看一张图：

[![Brskod.md.jpg](https://s1.ax1x.com/2020/11/02/Brskod.md.jpg)](https://imgchr.com/i/Brskod)

模式串为`aaa`，主串为`bbbbbb`，很明显完全不能匹配，我们直接向后划四位。

好了，现在的问题是，怎样计算出向后划的位数？毕竟我们是写程序的，总不能一直让人来判断。所以需要总结一下规律。

我们记**坏字符**在**模式串**(是模式串)中的下标为`j`，记坏字符在**模式串**中出现的下标为`i`，如果没有出现，则取`i`为$-1$。这样一来，我们将模式串向后划的位数就是`j - i`。**这就是规律**，不需要人来思考，机器与算法就可以处理的规则。其实还有一个问题，如果坏字符在模式串中多次出现，那么我们应该取哪个下标作为`i`的值呢？为了避免我们向后划的太*狠*而错过正确匹配的情况，我们取最大的那个下标。

其实还有一个问题，**这个下标应该怎么获得呢？**每次都计算一次当然也可以，但这样时间复杂度不就上去了么。追求高效就得另谋他路。考虑到我们的模式串其实是固定的，所以我们可以维护一个**哈希表**来存储每个字符在模式串中最后一次出现的位置，如果该字符没有出现过则使用默认值$-1$，当我们得到一个坏字符后从哈希表中取出他在模式串中的下标，因为哈希表存取的时间复杂度为$O(1)$，所以可以维持高效性。

> 那么来稍微分析一下利用坏字符规则的BM算法的时间复杂度，在最好情况下他的时间复杂度可以达到$O(m/n)$，这时候你要说我有问题了。凭什么用BM的最好时间复杂度和BF的最坏事件复杂度做对比。但总之BM算法就是出了名的高效。。

这么来看似乎坏字符一个规则就够用了，但真的是这样么？当然不是了。

注意我们为了保持取坏字符在模式串中的下标的高效性，使用了哈希表存储每个字符在模式串中**最后一次**出现的位置，我们记这个位置为`i`吧，坏字符的下标依旧是`j`，(这两个下标都是模式串中的)，**这个`i`不一定小于`j`**。也就是说，我们通过坏字符规则得到的后移位数可能是**负值**。

考虑这样一个栗子：
$$
primary = aaaaaa\\
pattern = ba
$$
这样我们计算出来的位移量就是负值，那该怎么办呢？不使用哈希表么？怎么可能呢。不是还有**好后缀**规则么。

#### 好后缀

什么叫做好后缀呢？因为我们是从后向前遍历模式串进行匹配的，所以已经匹配了的那个最后面的子串就被称为**好后缀**。很形象。

那么这个规则要怎么使用呢？这个规则怎么描述呢？

继续看图：

[![BrhSSJ.md.jpg](https://s1.ax1x.com/2020/11/02/BrhSSJ.md.jpg)](https://imgchr.com/i/BrhSSJ)

观察发现，如果我们的模式串中存在一个子串与好后缀匹配，则我们可以将该子串移到好后缀处即可实现一次移动数位字符的目标，同时还能保证匹配的正确性。如果有多个子串与好后缀匹配呢？为了避免移动过多，自然还是要选择最后面的那个子串。

具体来讲，我们记**坏字符在模式串中的下标为`j`**，记**与好后缀匹配的子串的起始下标为`i`**，我们要移动的位数就是$j + 1 - i$位。如果不存在一个子串与好后缀匹配，则我们直接移动`m`位(m是模式串的长度)(因为不存在子串与好后缀匹配则代表必定不可能匹配，毕竟好后缀也是模式串的一部分)。具体来讲要怎么做呢？

我们在得到好后缀之后遍历模式串得到与其匹配的子串下标显然是不可行的，效率太低。但实际上我们的后缀子串依旧是存在于模式串中的，而就像处理坏字符规则的时候一样，模式串是不会变动的，所以我们可以先行对模式串进行预处理，保存每个好后缀对应子串的起始下标。但这次我们可以不用哈希表，而是只使用一个数组`suffix`，这种方式非常的巧妙，可能也不是很好懂。**`suffix`的下标`i`的意义是长度为`i`的好后缀，而其中存储的值，`suffix[i]`的意义是长度为`i`的好后缀对应的子串的起始下标**。

可能不是很容易理解，我举个栗子：

```
pattern = "abcabc"
```

| 后缀长度 | 后缀串 | suffix |
| -------- | ------ | ------ |
| 1        | c      | 2      |
| 2        | bc     | 1      |
| 3        | abc    | 0      |
| 4        | cabc   | -1     |
| 5        | bcabc  | -1     |

我们刚才计算出的位移位数为$j+1-i$，`j`代表坏字符在模式串中的下标，`i`为与好后缀匹配的子串的起始下标，`suffix[x]`代表的是长度为`x`的好后缀所对应的匹配子串的起始下标，好后缀的长度可以通过$m - j - 1$计算得出，其中`m`是指模式串的长度，所以我们需要的位移量就是$j + 1 - suffix[m - j - 1]$，你可能注意到有的`suffix`的值为`-1`，这代表不存在子串匹配好后缀，这种情况下我们需要向后移动`m`个字符。

但这样就可以了么？其实不太性，考虑下图这种情况。

[![Brhpl9.md.jpg](https://s1.ax1x.com/2020/11/02/Brhpl9.md.jpg)](https://imgchr.com/i/Brhpl9)

模式串中没有子串与好后缀匹配，但好后缀的**一部分**可以与**模式串最前面的一部分**匹配，在这种情况下，如果我们按照紫色的移动方式，也就是我们上面介绍的那种移动方式，就可能错过绿色这种匹配结果。

那么该怎么办呢？

为了解决这个问题，首先我们在引入两个概念：前缀子串与后缀子串。所谓前缀子串，就是指第一个字符与本字符串对其的某个子串。而后缀子串，就是指最后一个字符与本字符串对其的某个子串。

我们刚才说到的这种没有考虑到的情况，实际上就是：**好后缀的后缀子串与模式串的前缀子串**有重合的情况。

那么怎么解决呢？其实也好办，这种位移过头的情况**只有在我们向后移动`m`位时才会发生**，换句话说，只有在不存在子串与好后缀匹配的情况下才会发生。

所以我们首先可以作出判断，只有在`suffix[x] == -1`，才需要判断是否有可能位移过头。

怎么判断位移过头了没有呢？刚才我们提到，导致这种情况的根本原因时好后缀的后缀子串与模式串的前缀子串有重合，**依旧都是模式串上的子串**，所以我们可以对模式串进行预处理，使用一个数组`prefix`**记录模式串的后缀子串是否与模式串的前缀子串匹配**。(因为好后缀本身就是模式串的后缀子串)。

怎么计算`suffix`与`prefix`的值呢？算法实在太多了。但我们追求高效不是么。下面我介绍一种比较高效的方法：

我们遍历模式串的前缀子串，记这个前缀子串为`s`，我们求**`s`的后缀子串**与模式串的后缀子串**最长**的可匹配长度，记这个公共后缀子串的长度为`k`，则我们更新`suffix[k] = j`，(`j`是`s`中后缀子串的起始下标)(为什么说更新，因为如果有多个匹配项，为了避免错过匹配成功的情况，我们希望向后划动的长度尽可能少)，如果`j == 0`，则置`prefix[k] == true`。

现在有了`prefix`，该怎么使用他来计算位移长度呢？如果`prefix[x] == true`，则说明长度为`x`的后缀子串与某个前缀子串匹配，我们将字符串的起始下标移动到`m - x`处即可，也就是，移动`m - x`位。

那么，坏字符与好后缀规则讲完了，来看看代码吧：

```java
import java.util.HashMap;
import java.util.Map;

public class BoyerMoore {
    // 坏字符规则所需要的保存字符与下标的对应关系的字典
    private Map<Character, Integer> indexMap;
    // 主串长度
    private int primaryLength;
	// 模式串长度   
    private int patternLength;
    // 好后缀对应的前缀子串的起始下标
    private int[] suffix;
    // 模式串的某个后缀子串是否匹配于某个前缀子串
    private boolean[] prefix;

    public BoyerMoore() {
        indexMap = new HashMap<>();
        primaryLength = 0;
        patternLength = 0;
    }

    public int bm(char[] primary, char[] pattern) {
        primaryLength = primary.length;
        patternLength = pattern.length;
        suffix = new int[patternLength];
        prefix = new boolean[patternLength];
		// 计算 suffix 与 prefix
        processSuffix(pattern);
        // 计算 indexMap
        for (int i = 0; i < patternLength; ++i)
            indexMap.put(pattern[i], i);
        // 分别根据两个规则计算的位移长度
        int badCharacterLength = 0, goodPrefixLength = 0;
        for (int i = 0; i <= primaryLength - patternLength;) {
            int moveLength = 0;
            int j;
            for (j = patternLength - 1; j >= 0; --j) {
                if (primary[i + j] != pattern[j]) {
                    // j是坏字符在模式串中的下标
                    break;
                }
            }
            // 匹配成功，返回匹配的字串的起始下标。
            if (j == -1)
                return i;
            // 根据坏字符规则计算的位移长度
            badCharacterLength = j - indexMap.getOrDefault(primary[i + j], -1);
            // 根据好后缀规则计算的位移长度
            goodPrefixLength = getGoodCharacterLength(j);
            moveLength = Math.max(badCharacterLength, goodPrefixLength);
            i += moveLength;
        }
        return -1;
    }

    private int getGoodCharacterLength(int j) {
        int goodSuffixLength = patternLength - 1 - j;
        if (goodSuffixLength == 0)
            return 0;
        // 如果模式串中存在子串与好后缀匹配
        if (suffix[goodSuffixLength] != -1)
            return j - suffix[goodSuffixLength] + 1;
        // 不存在子串与好后缀匹配
        // 寻找好后缀最长的一个后缀子串匹配于模式串的前缀子串
        // j是坏字符的下标，j+1是好后缀起始下标，已经知道好后缀没有匹配的子串了，故从j+2开始
        for (int r = j + 2; r < patternLength; ++r)
            // 和之前说的有点不一样，但其实一样的。
            if (prefix[m - r])
                return r;
        // 也没找到。。。
        return patternLength;
    }

    private void processSuffix(char[] pattern) {
        // 初始化
        for (int i = 0; i < patternLength; ++i) {
            suffix[i] = -1;
            prefix[i] = false;
        }
        for (int i = 0; i < patternLength - 1; ++i) {
            int j = i;
            int k = 0;
            while (j > -1 && pattern[j] == pattern[patternLength - 1 - k]) {
                ++k;
                --j;
                suffix[k] = j + 1;
            }
            if (j == -1)
                prefix[k] = true;
        }
    }
}
```

