---
layout:     post
title:      leetcode-31
subtitle:   leetcode
date:       2020-11-10
author:     scpi
header-img: img/leetcode_background.jpg
catalog:	true
tags:
    - leetcode
---



[31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)

每日一题。中等难度，说实话很简单，两次扫描就可以，但既然这么简单为什么还要写出来呢？

因为自己太蠢。不知道是不是因为太困了有点神志不清。

```
实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
```

其实没什么好说的，观察发现这其实就是一个全排列的一部分，需要输出全排列中比当前序列大的所有序列中最小那个，也就是下一个序列。

记当前串为`s`，观察发现对于`s`来说正确的下一个序列应该是变化最小的哪个序列，因为前面的数字权重高，所以我们应该尽可能变更后面的数字。

**变化最小**，也就是说前面的子串能不变就不变呗。

所以从最后一个字符开始，向前扫描，记其下标为`i`，当`nums[i-1]>=num[i]`时，说明`i-1`与`i`这个子串是最大的，这是显然的吧。。就好像`3>2`，所以`32>23`，所以我们一直遍历`i`，直到`nums[i-1]<nums[i]`，这说明`nums[i-1,...,nums.length-1]`这个子串并不是最大的(不用解释了吧。`231`很明显不是`1,2,3`能组成的最大的串吧)。所以我们要做的就是找到`nums[i-1,...,nums.length-1]`这个子串的下一个序列。

怎么找呢？其实很简单，我们找到`nums[i],...,nums[nums.length-1]`中**比`nums[i-1]`大的所有数字中最小那个**。有点绕口，但其实很好理解啦。(这就是我觉得自己蠢的地方，明显`nums[i]`之后的元素都是有序的，我却遍历了一遍去寻找。)，因为`nums[i]`之后的元素都是有序的，所以我们逆序遍历`nums[i],...,nums[nums.length-1]`这个子序列并寻找第一个大于`nums[i-1]`的元素，这就是我们要找的元素。记这个元素的下标为`maxAbove`吧。

交换`nums[i-1]`与`nums[maxAbove]`的值，并对`nums[i],...,nums[nums.length-1]`这个子序列重新进行升序排序，我们就得到了结果。

其实这是道数学题呀。。

> 最近博客写的比较少。
>
> 因为学校的数据库课程设计要验收了，所以在加班加点地做。做完之后大概会发一篇文章。
>
> 第一次使用Spring做这种东西，虽然走了一些弯路，但总的来说并没有那么丢人。等做完再说吧。